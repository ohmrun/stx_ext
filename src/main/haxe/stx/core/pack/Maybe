package stx.core.pack;

/**
  Similar to the `haxe.ds.Option` class with little runtime overhead.

  At this point, `import hx.Maybe.[static]` will not work.
**/
abstract Maybe<T>(Null<Dynamic>) from Null<T>{

  /**
    Constructor. new Maybe(any_value);
  */
  public function new(self) this = self;

  /**Unit function, type will be inferred down the line.**/
  static public inline function unit<T>():Maybe<T> return Maybes.unit();
  /**Static constructor**/
  static public inline function pure<T>(v:T):Maybe<T> return Maybes.pure(v);

  @:from @:noUsing static private inline function fromNull_A<A>(v:Null<A>):Maybe<A> return new Maybe(v);


  /** If there is a value, apply fn to it, if not, don't.*/
  public inline function map<U>(fn:T->U):Maybe<U>                 return Maybes._.map(fn,this);
  public inline function is_defined():Bool                        return Maybes._.is_defined(this);
  /*Fun a function that produces a Maybe over the current value. Will not run if this is null*/
  public inline function flat_map<U>(fn:T->Maybe<U>):Maybe<U>         return Maybes._.flat_map(fn,this);
  /**Zip two maybes together as a Tuple. Will only work if both*/
  public inline function zip<U>(that:Maybe<U>):Maybe<Tuple<T,U>> return Maybes._.zip(that,this);
  /**Uses `that` as a value if `this` is null.*/
  public inline function or(that:Void->Maybe<T>):Maybe<T>         return Maybes._.or(that,this);
  public inline function defv(elseVal:T):T                        return Maybes._.defv(elseVal,this);
  public inline function def(elseVal:Void->T):T                   return Maybes._.def(elseVal,this);


  /** Will produce an `Option` safetly from any value.*/
  @:to public function toOption():Option<T>                       return Maybes._.toOption(this);
  public function prj():Null<T>                                   return this;
  public function promote():T                                     return this;
}