package stx.core.pack;

import Type.ValueType;
import tink.core.Error.Stack;

//mostly tink_core

@:allow(stx.core)class Err<T>{
  static public var UUID(default,never):String      = "6fc8ec83-a9d6-4fe5-b09b-f3e29ebc520f";
  public var uuid(get,null)                 : String;
  private function get_uuid(){
    return UUID;
  }
  public var code(default,null)             : ErrorCode;
  public var pos(default,null)              : Position;

  public var callStack(default, null)       : Stack;
  public var exceptionStack(default, null)  : Stack;

  public var message(default,null)          : Option<StdString>;
  public var data(default,null)             : Option<StxFailure<T>>;

  public var prev(default,null)             : Option<Err<T>>;
  
  private function new(?code:ErrorCode, ?message:Option<String>, ?data:Option<StxFailure<T>>, ?prev:Option<Err<T>>, ?pos:Pos){
    this.code         = code == null ? ErrorCode.inj().five_hundred() : code;
    this.pos          = pos;
    this.message      = message;
    this.prev         = prev;
    this.data         = data;

    this.exceptionStack = #if error_stack try haxe.CallStack.exceptionStack() catch(e:Dynamic) #end [];
    this.callStack = #if error_stack try haxe.CallStack.callStack() catch(e:Dynamic) #end [];
  }
  @:access(stx.core.pack.ErrorCode)
  static public function fromTinkError(err:tink.core.Error):Err<Dynamic>{
    var next_error = make(new ErrorCode(err.code),err.message,ERR_(err.data),err.pos);
    return next_error;

  }
  static public function make<T>(code:ErrorCode, message:Option<String>, data:Option<StxFailure<T>>, ?prev:Option<Err<T>>, ?pos:Pos):Err<T>{
    code = __.option(code).defv(ErrorCode.inj().five_hundred());
    return new Err(code,message,data,prev,pos);
  }
  public function withFailure(data:T):Err<T>{
    var err                 = make(this.code,this.message,this.data,this.prev.fudge(),this.pos);
        err.callStack       = this.callStack;
        err.exceptionStack  = this.exceptionStack;
    return err; 
  }
  public function map<U>(fn:T->U):Err<U>{
    var next_data = this.data.map(
      function (t:StxFailure<T>) : StxFailure<U> {
        return switch(t){
          case ERR_(t)            : ERR_(fn(t));
          case ERR_STX(spec)      : ERR_STX(spec);
        }
      }
    );
    var next_prev : Option<Err<U>> = switch(this.prev){
      case Some(err)  : Some(err.map(fn));
      case null       : None;
      default         : None;
    };

    return new Err(
      this.code,
      this.message,
      next_data,
      next_prev,
      this.pos
    );
  }
  public function copy(?code:ErrorCode,?message:Option<String>,?data:Option<StxFailure<T>>,?prev:Option<Err<T>>,?pos:Pos):Err<T>{
    return make(
      __.option(code).defv(this.code),
      __.option(message).defv(this.message),
      __.option(data).defv(this.data),
      __.option(prev).defv(this.prev),
      __.option(pos).defv(this.pos)
    );
  }
  public function last(){
    var last = this;
    while(last.prev.is_defined()){
      last = last.prev.fudge();
    }
    return last;
  }
  public function next(that:Err<T>):Err<T>{
    var last  = that.copy();
    var stack : Array<Err<T>> = [];
    while(last.prev.is_defined()){
      stack.push(last.prev.fudge());
      last = last.prev.fudge();
    }
    var next = Lambda.fold(stack,
      (next:Err<T>,memo:Err<T>) -> next.copy(null,null,null,memo),
      this
    );
    return next;
  }
  public function head():Option<T>{
    return switch(this.data){
      case Some(ERR_(v))  : Some(v);
      default             : None;
    }
  }
  // public function iterator():Iterator<Null<StxFailure<T>>>{
  //   var it = null;
  //       it = {
  //         next : function(){
  //           var v = this.data;
  //           if(this.prev.is_defined()){
  //             it = this.prev.fudge().iterator();
  //           }
  //           return v.fudge();
  //         },
  //         hasNext : function(){
  //           return this.prev.is_defined();
  //         }
  //       };
  //   return{
  //     next    : () -> it.next(),
  //     hasNext : () -> it.hasNext()
  //   };
  // }
  public function fault():Fault{
    return this.pos;
  }
  public function promote():Err<T>{
    return this;
  }
  public function elide():Err<Dynamic>{
    return this;
  }
  public function at(pos){
    return copy(null,null,null,null,pos);
  }
  public function throwSelf():Dynamic
    return
      #if macro
        #if tink_macro
          tink.macro.Positions.error(pos, message);
        #else
          haxe.macro.Context.error(message.fudge(), if (pos == null) haxe.macro.Context.currentPos() else pos);
        #end
      #else
        rethrow(this);
      #end

  static public inline function rethrow(any:Dynamic):Dynamic {
    #if neko
      neko.Lib.rethrow(any);
    #elseif php
      php.Lib.rethrow(any);
    #elseif cpp
      cpp.Lib.rethrow(any);
    #else
      throw any;
    #end
    return any;
  }
  public function toString():String{
    var msg           = message.map( _ -> '"$_"').defv('');
    var typ           = data.map(Std.string).defv('');
    var idx           = None.core();
    var dat : Dynamic = data.fudge();
    var lib_id        = None.core();
    var enum_id       = None.core();

    #if !macro
      //var val           = new stx.env.haxelib.Name();
      //var lib_id        = val == ""  ? None.core() : Some('$val').core();
    #end
  
    switch (StdType.typeof(dat)){
      case ValueType.TEnum(e) :
        enum_id       = Some(StdType.getEnumName(e)).core();
        var enum_bits = enum_id.map(_ -> _.split(".")).defv([]);
        var enum_name = enum_bits[enum_bits.length-1];
        var index     = StdType.enumIndex(cast dat);
        idx = lib_id.fold(
          (v) -> Some('(${enum_name}:$index)'),
          ()  -> Some('(${enum_id}:$index)')
        );
        idx           = Some('${enum_name}:$index').core();
      default: null;
    }

    
    var out =  '(:stx.error (${code} (${typ} ${msg}) at $pos))';
    if(callStack != null){
      var calls = callStack.map(Std.string).join("\n\t");
      out = '${out}\n\t${calls}';
    } else if (exceptionStack != null){
      var calls = exceptionStack.map(Std.string).join("\n\t");
      out = '${out}\n\t${calls}';
    }
    return out;
  }

}