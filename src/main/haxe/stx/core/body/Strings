package stx.core.body;


using StringTools;

@:noUsing class Strings extends Clazz{
  
  /**
		Returns `true` if `v` is `'true'` or `'1'`, `false` if `'false'` or `'0'` and `d` otherwise.
	**/
  @:noUsing public function parse_bool(v: String): Option<Bool> {
    var vLower = v.toLowerCase();

    return switch([vLower,v]){
      case ['false',_] | [_,'0']  : Some(false);
      case ['true',_] | [_,'1']   : Some(true);
      default                     : None;
    }
  }

  @:noUsing public function parse_int(self: String):Option<Int> {
    return 
      __.option(Std.parseInt(self))
        .filter(function(i) return !Math.isNaN(i));
  }
   @:noUsing public function parse_float(self: String):Option<Float> {
    return 
      __.option(Std.parseFloat(self))
     .filter(function(i) return !Math.isNaN(i));
  }
  /**
		Returns `true` if `frag` is at the beginning of `v`, `false` otherwise.
	**/
  @:noUsing public function starts_with(frag: String,self: String): Bool {
    return if (v.length >= frag.length && frag == self.substr(0, frag.length)) true else false;
  }
  /**
		Returns `true` if `frag` is at the end of `v`, `false` otherwise.
	**/
  @:noUsing public function ends_with(frag: String,self: String): Bool {
    return if (v.length >= frag.length && frag == self.substr(v.length - frag.length)) true else false;
  }
  /**
		Returns true if v contains s, false otherwise.
	**/
  @:noUsing public function contains(substr: String, self: String): Bool {
    return self.indexOf(substr) != -1;
  }
  /**
		Returns a String where sub is replaced by by in s.
	**/
  @:noUsing public function replace(sub : String, by : String, self : String ) : String {
    return StringTools.replace(self, sub, by);
  }
  /**
		Surrounds `v`, prepending `l` and concating `r`.
	**/
  public function brackets(l:String,r:String,self:String){
    return '$l$self$r';
  }
  /**
		prepend `before` on `str.`
	**/
  public function prepend(before:String,self:String){
    return before + self;
  }
  /**
		concat `before` on `str.`
	**/
  public function append(after:String,self:String){
    return self + after;
  }
  /**
		Get character code from `str` at index `i`.
	**/
  public function cca(i:Int,self:String){
    return self.charCodeAt(i);
  }
  public function at(i:Int,self:String):String{
    return self.charAt(i);
  }
  /**
		Returns an Array of `str` divided into sections of length `len`.
	**/
  public function chunk(len: Int = 1,self: String): Array<String> {
    var start = 0;
    var end   = (start + len).min(self.length);

    return if (end == 0) [];
     else {
       var prefix = self.subself(start, end);
       var rest   = str.substr(end);

       [prefix].concat(chunk(rest, len));
     }
  }
  /**
		Returns an Array of the characters of `str`.
	**/
  public function chars(self: String): Array<String> {
    var a = [];

    for (i in 0...self.length) {
      a.push(self.charAt(i));
    }

    return a;
  }
  /**
		Turns a slugged or underscored string into a camelCase string.
	**/
  public function toCamelCase(self: String): String {
    return SepAlphaPattern.map(self, function(e) { return e.matched(2).toUpperCase(); });
  }
  /**
		Replaces uppercased letters with prefix `sep` + lowercase.
	**/
  public function fromCamelCase(sep: String,self: String="_"): String {
    return AlphaUpperAlphaPattern.map(self, function(e) { return e.matched(1) + sep + e.matched(2).toLowerCase(); });
  }
  /**
		Split `st` at `sep`.
	**/
  public function split(sep:String,self:String):Array<String>{
    return st.split(sep);
  }
  /**
		Strip whitespace out of a string.
	**/
  public function stripWhite( s : String ) : String {
    var l = s.length;
    var i = 0;
    var sb = new StringBuf();
    while( i < l ) {
      if(!isSpace(s, i))
        sb.add(s.charAt(i));
      i++;
    }
    return sb.toString();
  }
  /**
		Continues to replace `sub` with `by` until no more instances of `sub` exist.
	**/
  public function replaceRecurse( s : String, sub : String, by : String ) : String {
    if(sub.length == 0)
      return replace(s, sub, by);
    if(by.indexOf(sub) >= 0)
      throw "Infinite recursion";
    var ns : String = s.toString();
    var olen = 0;
    var nlen = ns.length;
    while(olen != nlen) {
      olen = ns.length;
      replace( ns, sub, by );
      nlen = ns.length;
    }
    return ns;
  }
  /**
		Returns an iterator of `value`.
	**/
  public function iterator(value : String) : Iterator<String> {
    var index = 0;
    return {
        hasNext: function() {
            return index < value.length;
        },
        next: function() {
            return if (index < value.length) {
                value.substr(index++, 1);
            } else {
              throw __.fault().of(IndexOutOfBounds);
            }
        }
    };
  }
  /*
  public function camelCaseToDashes(value : String) : String {
    var regexp = new EReg("([a-zA-Z])(?=[A-Z])", "g");
    return regexp.replace(value, "$1-");
  }

  public function camelCaseToLowerCase(value : String, ?separator : String = "_") : String {
    var reg = new EReg("([^\\A])([A-Z])", "g");
    return reg.replace(value, '$1${separator}$2').toLowerCase();
  }
  public function camelCaseToUpperCase(value : String, ?separator : String = "_") : String {
    var reg = new EReg("([^\\A])([A-Z])", "g");
    return reg.replace(value, '$1${separator}$2').toUpperCase();
  }*/
  public function is_space(pos : Int, self : String ) : Bool {
    var c = self.charCodeAt( pos );
    return (c >= 9 && c <= 13) || c == 32;
  }
  public inline function chr(i:Int){
    return String.fromCharCode(i);
  }
  @thx
  public static function underscore(s : String):String {
    s = (~/::/g).replace(s, '/');
    s = (~/([A-Z]+)([A-Z][a-z])/g).replace(s, '$1_$2');
    s = (~/([a-z\d])([A-Z])/g).replace(s, '$1_$2');
    s = (~/-/g).replace(s, '_');
    return s.toLowerCase();
  }
  /**
   * Returns all characters from a that appear after the first occurence of sub, or,
   * if sub does not occur in a, empty string.
   **/
  public static function after(a: String, sub: String): String {
    var idx = a.indexOf(sub);
    if (idx < 0) return "";
    return a.substring(idx + sub.length, a.length);
  }
  /**
   * Returns all characters from a that appear before the first occurence of sub, or,
   * if sub does not occur in a, empty string.
   **/
  public static function before(a: String, sub: String): String {
    return a.substring(0, a.indexOf(sub));
  }
  public function quote(str:String):String{
    return '\"$str\"';
  }
  public function requote(str:String):String{
    return str.replace("\"","\\\"");
  }
}
