package stx.core.body;

import stx.core.body.Options;

using StringTools;

@:noUsing class Strings {
  /**
		Unit function.
	**/
  @:noUsing static public function unit():String{
    return '';
  }
  static var Requote                = ~/"([^"\\]*(\\.[^"\\]*)*)"|\\'([^\\'\\]*(\\.[^\\'\\]*)*)\\'/;
  static var SepAlphaPattern        = ~/(-|_)([a-z])/g;
  static var AlphaUpperAlphaPattern = ~/-([a-z])([A-Z])/g;

  /**
		Returns `true` if `v` is `'true'` or `'1'`, `false` if `'false'` or `'0'` and `d` otherwise.
	**/
  @:noUsing static public function toBool(v: String, d: Bool): Bool {
    if (v == null) return d;

    var vLower = v.toLowerCase();

    return switch([vLower,v]){
      case ['false',_] | [_,'0'] : false;
      case ['true',_] | [_,'1']  : true;
      default : d;
    }
  }
  @:noUsing static public function int(v: String):Option<Int> {
    if (v == null) return None;

    return 
      Options.option(Std.parseInt(v))
     .filter(function(i) return !Math.isNaN(i));
  }
   @:noUsing static public function float(v: String):Option<Float> {
    if (v == null) return None;

    return 
      Options.option(Std.parseFloat(v))
     .filter(function(i) return !Math.isNaN(i));
  }
  /**
		Returns `true` if `frag` is at the beginning of `v`, `false` otherwise.
	**/
  @:noUsing static public function startsWith(v: String, frag: String): Bool {
    return if (v.length >= frag.length && frag == v.substr(0, frag.length)) true else false;
  }
  /**
		Returns `true` if `frag` is at the end of `v`, `false` otherwise.
	**/
  @:noUsing static public function endsWith(v: String, frag: String): Bool {
    return if (v.length >= frag.length && frag == v.substr(v.length - frag.length)) true else false;
  }
  /**
		Returns true if v contains s, false otherwise.
	**/
  @:noUsing static public function contains(v: String, s: String): Bool {
    return v.indexOf(s) != -1;
  }
  /**
		Returns a String where sub is replaced by by in s.
	**/
  @:noUsing static public function replace( s : String, sub : String, by : String ) : String {
    return StringTools.replace(s, sub, by);
  }
  /**
		Surrounds `v`, prepending `l` and concating `r`.
	**/
  static public function brackets(v:String,l:String,r:String){
    return '$l$v$r';
  }
  /**
		prepend `before` on `str.`
	**/
  static public function prepend(str:String,before:String){
    return before + str;
  }
  /**
		concat `before` on `str.`
	**/
  static public function append(str:String,after:String){
    return str + after;
  }
  /**
		Get character code from `str` at index `i`.
	**/
  static public function cca(str:String,i:Int){
    return str.charCodeAt(i);
  }
  static public function at(str:String,i:Int):String{
    return str.charAt(i);
  }
  /**
		Returns an Array of `str` divided into sections of length `len`.
	**/
  static public function chunk(str: String, len: Int = 1): Array<String> {
    var start = 0;
    var end   = (start + len).min(str.length);

    return if (end == 0) [];
     else {
       var prefix = str.substr(start, end);
       var rest   = str.substr(end);

       [prefix].concat(chunk(rest, len));
     }
  }
  /**
		Returns an Array of the characters of `str`.
	**/
  static public function chars(str: String): Array<String> {
    var a = [];

    for (i in 0...str.length) {
      a.push(str.charAt(i));
    }

    return a;
  }
  /**
		Returns a seamless joined string of `l`.
	**/
  static public function string(l: Iterable<String>): String {
    var o = '';
    for ( val in l) {
      o += val;
    }
    return o;
  }
  /**
		Turns a slugged or underscored string into a camelCase string.
	**/
  static public function toCamelCase(str: String): String {
    return SepAlphaPattern.map(str, function(e) { return e.matched(2).toUpperCase(); });
  }
  /**
		Replaces uppercased letters with prefix `sep` + lowercase.
	**/
  static public function fromCamelCase(str: String, sep: String): String {
    return AlphaUpperAlphaPattern.map(str, function(e) { return e.matched(1) + sep + e.matched(2).toLowerCase(); });
  }
  /**
		Split `st` at `sep`.
	**/
  static public function split(st:String,sep:String):Array<String>{
    return st.split(sep);
  }
  /**
		Strip whitespace out of a string.
	**/
  static public function stripWhite( s : String ) : String {
    var l = s.length;
    var i = 0;
    var sb = new StringBuf();
    while( i < l ) {
      if(!isSpace(s, i))
        sb.add(s.charAt(i));
      i++;
    }
    return sb.toString();
  }
  /**
		Continues to replace `sub` with `by` until no more instances of `sub` exist.
	**/
  static public function replaceRecurse( s : String, sub : String, by : String ) : String {
    if(sub.length == 0)
      return replace(s, sub, by);
    if(by.indexOf(sub) >= 0)
      throw "Infinite recursion";
    var ns : String = s.toString();
    var olen = 0;
    var nlen = ns.length;
    while(olen != nlen) {
      olen = ns.length;
      replace( ns, sub, by );
      nlen = ns.length;
    }
    return ns;
  }
  /**
		Returns an iterator of `value`.
	**/
  static public function iterator(value : String) : Iterator<String> {
    var index = 0;
    return {
        hasNext: function() {
            return index < value.length;
        },
        next: function() {
            return if (index < value.length) {
                value.substr(index++, 1);
            } else {
              throw Error.withData('Index of String out of bounds',null);
            }
        }
    };
  }
  static public function camelCaseToDashes(value : String) : String {
    var regexp = new EReg("([a-zA-Z])(?=[A-Z])", "g");
    return regexp.replace(value, "$1-");
  }

  static public function camelCaseToLowerCase(value : String, ?separator : String = "_") : String {
    var reg = new EReg("([^\\A])([A-Z])", "g");
    return reg.replace(value, '$1${separator}$2').toLowerCase();
  }
  static public function camelCaseToUpperCase(value : String, ?separator : String = "_") : String {
    var reg = new EReg("([^\\A])([A-Z])", "g");
    return reg.replace(value, '$1${separator}$2').toUpperCase();
  }
  static public function isSpace( s : String, pos : Int ) : Bool {
    var c = s.charCodeAt( pos );
    return (c >= 9 && c <= 13) || c == 32;
  }
  static public inline function chr(i:Int){
    return String.fromCharCode(i);
  }
  @thx
  public static function underscore(s : String):String {
    s = (~/::/g).replace(s, '/');
    s = (~/([A-Z]+)([A-Z][a-z])/g).replace(s, '$1_$2');
    s = (~/([a-z\d])([A-Z])/g).replace(s, '$1_$2');
    s = (~/-/g).replace(s, '_');
    return s.toLowerCase();
  }
  /**
   * Returns all characters from a that appear after the first occurence of sub, or,
   * if sub does not occur in a, empty string.
   **/
  public static function substringAfter(a: String, sub: String): String {
    var idx = a.indexOf(sub);
    if (idx < 0) return "";
    return a.substring(idx + sub.length, a.length);
  }
  /**
   * Returns all characters from a that appear before the first occurence of sub, or,
   * if sub does not occur in a, empty string.
   **/
  public static function substringBefore(a: String, sub: String): String {
    return a.substring(0, a.indexOf(sub));
  }
  static public function quote(str:String):String{
    return '\"$str\"';
  }
  static public function requote(str:String):String{
    return str.replace("\"","\\\"");
  }
}
