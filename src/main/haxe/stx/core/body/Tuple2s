package stx.core.body;

class Tuples extends Clazz{
    #if thx_core
      public function fromThxTuple<A,B>(tup:ThxTuple<A,B>):Tuple<A,B>{
        return Tuple(tup._0,tup._1);
      }

      public function toThxTuple<A,B>(tup:Tuple<A,B>):ThxTuple<A,B>{
        return new ThxTuple(fst(tup),snd(tup));
      }
    #end


    public function map<T1,T2,TZ>(fn:T2->TZ,tuple: Tuple<T1,T2>): Tuple<T1,TZ>{
      return switch tuple{
          case Tuple(l,r) : Tuple(l,fn(r));
      }
    }
    public function apply<T1,T2,R>(tuple: Tuple<T1->R,T1>){
        return fst(tuple)(snd(tuple));
    }
    public function fst<T1, T2>(tuple : Tuple<T1, T2>) : T1 {
        return switch (tuple){
            case Tuple(a,_)    : a;
        }
    }
    public function snd<T1, T2>(tuple : Tuple<T1, T2>) : T2 {
        return switch (tuple){
            case Tuple(_,b)    : b;
        }
    }
    public function swap<T1, T2>(tuple : Tuple<T1, T2>) : Tuple<T2, T1> {
        return switch (tuple) {
            case Tuple(a, b): Tuple(b, a);
        }
    }
    public function equals<T1, T2>(b : Tuple<T1, T2>,a : Tuple<T1, T2>) : Bool {
      return switch (a) {
        case Tuple(t0l, t0r):
            switch (b) {
              case Tuple(t1l, t1r) :  (t0l == t1l) && (t0r == t1r);
              default               : false;
            }
        default : false;
        }
    }
    public function toArray<T1, T2>(tuple : Tuple<T1, T2>) : Array<Dynamic> {
        return switch (tuple){
            case Tuple(a,b)    : [a,b];
        }
    }
}
