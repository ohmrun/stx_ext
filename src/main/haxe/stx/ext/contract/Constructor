package stx.ext.contract;

class Constructor extends Clazz{
  static public function unit<T,E>():Contract<T,E>{
    return Contract.pure(Tap);
  }
  static public function pure<T,E>(ch:Chunk<T,E>):Contract<T,E>{
    return Future.async(
      (f) -> f(ch)
    ); 
  }
  static public function bind_fold<T,Ti,E>(it:Array<T>,start:Ti,fm:Ti->T->Contract<Ti,E>):Contract<Ti,E>{
    return new Contract(__.core().Future().bind_fold(
      it,
      function(next:T,memo:Chunk<Ti,E>):Future<Chunk<Ti,E>>{
        return switch (memo){
          case Tap      : unit().prj();
          case Val(v)   : fm(v,next).prj();
          case End(err) : end(err).prj();
        }
      },
      Val(start)
    ));
  }
  static public function lazy<T,E>(fn:Void->T):Contract<T,E>{
    return Future.async(
      (f) -> f(Val(fn()))
    );
  }
  static public function fromLazyError<T,E>(fn:Void->Err<E>):Contract<T,E>{
    return fromLazyChunk(
      () -> End(fn())
    );
  }
  static public function fromLazyChunk<T,E>(fn:Void->Chunk<T,E>):Contract<T,E>{
    return Future.async(
      (f) -> f(fn())
    );
  }

  @:noUsing static public function end<T,E>(?e:Err<E>):Contract<T,E>{
    return pure(End(e));
  }
  @:noUsing static public function tap<T,E>():Contract<T,E>{
    return unit();
  }
  @:noUsing static public function fromChunk<T,E>(chk:Chunk<T,E>):Contract<T,E>{
    return Future.async(
      (cb) -> cb(
        chk
      )
    );
  }
  @:noUsing static public function fromOption<T,E>(m:Option<T>):Contract<T,E>{
    final val = m.fold((x)->Val(x),()->Tap);
    return fromChunk(val);
  }
}